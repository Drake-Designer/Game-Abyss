diff --git a/blog/migrations/0004_alter_blogpost_image.py b/blog/migrations/0004_alter_blogpost_image.py
index 4bfeee847d2379b484b9f4cbc29f54656582f180..c4ed6ec4c94e15ab42a0c40bffaa2752d8736980 100644
--- a/blog/migrations/0004_alter_blogpost_image.py
+++ b/blog/migrations/0004_alter_blogpost_image.py
@@ -1,19 +1,30 @@
 # Generated by Django 5.2.7 on 2025-10-21 20:12

-import cloudinary.models
-from django.db import migrations
+from django.db import migrations, models
+
+try:
+    import cloudinary.models
+except ImportError:  # pragma: no cover - optional dependency
+    cloudinary = None
+else:
+    cloudinary = cloudinary.models


 class Migration(migrations.Migration):

     dependencies = [
         ('blog', '0003_alter_blogpost_options_remove_blogpost_is_approved_and_more'),
     ]

     operations = [
         migrations.AlterField(
             model_name='blogpost',
             name='image',
-            field=cloudinary.models.CloudinaryField(blank=True, max_length=255, null=True, verbose_name='image'),
+            field=(
+                cloudinary.CloudinaryField(
+                    verbose_name='image', blank=True, null=True, max_length=255)
+                if cloudinary
+                else models.ImageField(
+                    upload_to='blog_images/', blank=True, null=True)),
         ),
     ]
diff --git a/blog/models.py b/blog/models.py
index 4952a7539867d5ff80e7633f7c10feb1a1a556fd..7d738243c38f3202b411deae9423875254222b99 100644
--- a/blog/models.py
+++ b/blog/models.py
@@ -64,54 +64,79 @@ class BlogPost(models.Model):
         verbose_name_plural = 'Blog Posts'

     def save(self, *args, **kwargs):
         """Auto-generate slug and compute reading time, then save.

         If `slug` is empty it is created from the title and published date.
         Reading time is estimated from the body text.
         """
         previous_status = None
         if self.pk:
             previous_status = BlogPost.objects.filter(pk=self.pk).values_list('status', flat=True).first()

         should_notify_rejection = (
             previous_status is not None
             and previous_status != self.STATUS_REJECTED
             and self.status == self.STATUS_REJECTED
         )

         if self.status == self.STATUS_APPROVED and not self.published_at:
             self.published_at = timezone.now()
         elif self.status == self.STATUS_REJECTED:
             self.published_at = None

         # Auto-generate slug from title if not set
         if not self.slug:
-            base_slug = slugify(self.title)[:100]
-            date_str = self.published_at.strftime(
-                '%Y-%m-%d') if self.published_at else timezone.now().strftime('%Y-%m-%d')
-            self.slug = f"{base_slug}-{date_str}"
+            slug_field = self._meta.get_field('slug')
+            base_slug = slugify(self.title)[:100] or 'post'
+            reference_dt = self.published_at or timezone.now()
+            date_str = reference_dt.strftime('%Y-%m-%d')
+            base_without_suffix = f"{base_slug}-{date_str}"[:slug_field.max_length].rstrip('-')
+
+            # Ensure slug uniqueness for the given publication date, including drafts
+            if self.pk:
+                existing = BlogPost.objects.exclude(pk=self.pk)
+            else:
+                existing = BlogPost.objects.all()
+
+            if self.published_at:
+                existing = existing.filter(published_at__date=reference_dt.date())
+            else:
+                existing = existing.filter(published_at__isnull=True)
+
+            unique_slug = base_without_suffix
+            counter = 2
+            while existing.filter(slug=unique_slug).exists():
+                suffix = f"-{counter}"
+                allowed_length = slug_field.max_length - len(suffix)
+                trimmed_base = base_without_suffix[:max(allowed_length, 1)].rstrip('-')
+                if not trimmed_base:
+                    trimmed_base = base_without_suffix[:1] or 'post'
+                unique_slug = f"{trimmed_base}{suffix}"
+                counter += 1
+
+            self.slug = unique_slug
         # Calculate reading time (roughly 200 words/minute)
         if self.body:
             words = len(self.body.split())
             self.reading_time = max(1, words // 200)
         super().save(*args, **kwargs)

         if should_notify_rejection and self.author.email:
             def _send_rejection_email():
                 send_mail(
                     subject=f"Il tuo post '{self.title}' non è stato approvato",
                     message=(
                         "Ciao {username},\n\n"
                         "il tuo post non è stato approvato dalla redazione e non sarà visibile sul blog.\n"
                         "Puoi aggiornarlo e riproporlo per la revisione in qualsiasi momento.\n\n"
                         "Grazie per aver contribuito a Game Abyss!"
                     ).format(username=self.author.get_username()),
                     from_email=getattr(settings, 'DEFAULT_FROM_EMAIL', None),
                     recipient_list=[self.author.email],
                     fail_silently=True,
                 )

             transaction.on_commit(_send_rejection_email)

     def __str__(self):
         return self.title
diff --git a/blog/tests.py b/blog/tests.py
index 7ce503c2dd97ba78597f6ff6e4393132753573f6..692c50dd3756df5647d34a5ccfd7b8171cc2d2c0 100644
--- a/blog/tests.py
+++ b/blog/tests.py
@@ -1,3 +1,51 @@
+from django.contrib.auth import get_user_model
 from django.test import TestCase
+from django.utils import timezone

-# Create your tests here.
+from .models import BlogPost
+
+
+class BlogPostModelTests(TestCase):
+
+    def setUp(self):
+        self.user = get_user_model().objects.create_user(
+            username='author', password='pass')
+
+    def test_slug_unique_for_same_day_drafts(self):
+        """Multiple drafts with the same title should not crash and get unique slugs."""
+
+        first = BlogPost.objects.create(
+            author=self.user,
+            title='My Duplicate Title',
+            body='content')
+        second = BlogPost.objects.create(
+            author=self.user,
+            title='My Duplicate Title',
+            body='another content')
+
+        self.assertNotEqual(first.slug, '')
+        self.assertNotEqual(second.slug, '')
+        self.assertNotEqual(first.slug, second.slug)
+        self.assertTrue(second.slug.endswith('-2'))
+
+    def test_slug_unique_for_published_posts_same_day(self):
+        """Approved posts on the same day also receive a unique slug suffix."""
+
+        now = timezone.now()
+        post_one = BlogPost.objects.create(
+            author=self.user,
+            title='Launch Day',
+            body='body',
+            status=BlogPost.STATUS_APPROVED,
+            published_at=now,
+        )
+        post_two = BlogPost.objects.create(
+            author=self.user,
+            title='Launch Day',
+            body='body',
+            status=BlogPost.STATUS_APPROVED,
+            published_at=now,
+        )
+
+        self.assertTrue(post_two.slug.endswith('-2'))
+        self.assertNotEqual(post_one.slug, post_two.slug)
